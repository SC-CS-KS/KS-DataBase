# 查询算法
* 顺序查找（linear search ）
* 二分查找（binary search）
```md
有序数组
```
* 二叉排序树查找 
```md
时间复杂度： O(log2N)
```
* 哈希散列法(哈希表)
```md
时间复杂度：几乎是O(1)，取决于产生冲突的多少。
缺点：不适用范围查找
```
* 分块查找
```md
分块查找又称索引顺序查找，它是顺序查找的一种改进方法。

算法思想：是将n个数据元素”按块有序”划分为m块（m ≤ n）。
    每一块中的结点不必有序，但块与块之间必须”按块有序”；
    即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；
    而第2块中任一元素又都必须小于第3块中的任一元素，依次类推。

算法流程：
1. 先选取各块中的最大关键字构成一个索引表；
2. 查找分两个部分：
    先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；
    然后，在已确定的块中用顺序法进行查找。
```

* 平衡多路搜索树B树（B-tree）
```md
二叉树，它的搜索时间复杂度为O(log2N)，所以它的搜索效率和树的深度有关，
如果要提高查询速度，那么就要降低树的深度。
要降低树的深度，很自然的方法就是采用多叉树，再结合平衡二叉树的思想，可以构建一个平衡多叉树结构，
然后就可以在上面构建平衡多路查找算法，提高大数据量下的搜索效率。
```
* * B Tree
* * B+Tree
```md
B-Tree相比，B+Tree有以下不同点：
内节点不存储data，只存储key；
叶子节点不存储指针。
```
* * 带有顺序访问指针的 B+Tree
```md
做这个优化的目的是为了提高区间访问的性能。
```
* 总结
```md
每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，
但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），
所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，
这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。
```
## Why B+Tree?
```md
一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。
索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，
所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。
换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。
```
* 局部性原理与磁盘预读
```md
为了提高效率，要尽量减少磁盘I/O，磁盘往往不是严格按需读取，
而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。

这样做的理论依据是计算机科学中著名的局部性原理：
当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。

由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），
因此对于具有局部性的程序来说，预读可以提高I/O效率。

预读的长度一般为页（page）的整倍数。
页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，
每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。
当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁
盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。
```
* B树
```md
根据B-Tree的定义，可知检索一次最多需要访问h-1个节点（根节点常驻内存）。
数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。

为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：
每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，
加之计算机存储分配都是按页对齐的，就实现了一个 node 只需一次 I/O。

B-Tree 中一次检索最多需要 h-1 次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。
一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。
```
* B+树
```md
B树 的搜索复杂度为 O(h)=O(logdN)，所以树的出度d越大，深度h就越小，I/O的次数就越少。
B+Tree 恰恰可以增加出度d的宽度，因为每个节点大小为一个页大小，所以出度的上限取决于节点内 key 和 data 的大小。
dmax = floor(pagesize/(keysize + datasize + pointsize ))//floor表示向下取整
由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，从而拥有更好的性能。
```
* 总结
```md
真实的情况是，3层的b+树可以表示上百万的数据，
如果上百万的数据查找只需要三次IO，性能提高将是巨大的，
如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。
```



